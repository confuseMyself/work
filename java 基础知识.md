# java 基础知识





##*java基础语法*

- **大小写敏感**：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。

- **类名**：*<font color=red>对于所有的类来说，类名的首字母应该大写</font>*。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 **MyFirstJavaClass**。

- **方法名**：*<font color=red>所有的方法名都应该以小写字母开头。</font>*如果方法名含有若干单词，则后面的每个单词首字母大写。

- **源文件名**：*<font color=red>源文件名必须和类名相同。</font>*当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）。一个源文件里最多只有一个public类。

- **主方法入口**：所有的 Java 程序由 *<font color=red>public static void main(String []args)</font>* 方法开始执行，一个应用只有一个主程序入口

  

## *java源文件的声明规则*

当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。

- 一个源文件中只能有一个public类
- 一个源文件可以有多个非public类
- 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。
- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。
- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。
- import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。





##*java标识符*

 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 

关于 Java 标识符，有以下几点需要注意：

- 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
- 关键字不能用作标识符
- 标识符是大小写敏感的
- 合法标识符举例：age、$salary、_value、__1_value
- 非法标识符举例：123abc、-salary

##*java修饰符*

像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized

## *java变量*

Java 中主要有如下几种类型的变量

- 局部变量：定义在方法内或者在代码快中的变量
- 类变量（静态变量）static 声明的变量
- 成员变量（非静态变量）

## *java关键字*

###访问控制修饰词

|   类别   |  关键字   |   说明   |         修饰对象         |
| :------: | :-------: | :------: | :----------------------: |
| 访问控制 |  private  |  私有的  | （成员）成员变量和类方法 |
|          | protected | 受保护的 | （成员）成员变量和类方法 |
|          |  public   |  公共的  |         类、成员         |
|          | friendly  |   默认   |         类、成员         |

private:**用于修饰类中的成员**（成员变量和成员方法）,只能本类中被访问；

public：**可以用来修饰类的成员和类，表示任何情况都能访问**

- 用与修饰类和类中的成员，当修饰一个类时，表示可以被其它包中的类访问；

- 当修饰类中的成员时，表示该成员可以被其它包中的类访问

protected：**用来修饰类的成员**

   ***用保护访问控制符 protected 修饰的类成员可以被三种类所访问：***

-  该类自身 
-  与它在同一个包中的其他类 
-  在其他包中的该类的子类 

friendly:默认，如果一个类或者成员没有显示定义访问修饰词，则默认为friendly

​    表示本包范围内可以访问

------



### java类型

java数据类型分为

***基础类型***

***引用类型：类似c语言里的指针，一旦声明了类型，就不能更改***



|   类型   | 关键字  |    说明    |     默认值     |
| :------: | :-----: | :--------: | :------------: |
| 基本类型 | boolean |  布尔类型  |     false      |
|          |  byte   |   字节型   | '/uoooo'(null) |
|          |  char   |   字符型   |    (byte)0     |
|          | double  | 双精度浮点 |    (short)0    |
|          |  float  | 单精度浮点 |      0.0f      |
|          |   int   |    整型    |       0        |
|          |  long   |   长整型   |      0.0d      |
|          |  short  |   短整型   |    (short)0    |



|   类型   | 关键字 |    说明    | 默认值 |
| :------: | :----: | :--------: | :----: |
| 引用类型 | super  | 父类、超类 |        |
|          |  this  |    本类    |        |
|          |  void  |  无返回值  |        |

------



### java变量

**java变量分为**

***类变量***

- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。
- 静态变量在第一次被访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：*ClassName.VariableName*的方式访问。
- 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。

***成员变量（实列变量）***

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。

独立于方法之外的变量，没有用static修饰

***局部变量***

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。



------

### *java数组*

 Java 语言中提供的数组是用来<font color=red>存储固定大小的同类型元素 </font>

**声明数组变量**

 dataType[] arrayName ： int[]  a ,声明一个数组，数组成员的数据类型为int类型

**创建数组**

```java
arrayRefVar = new dataType[arraySize];
```

上面的语法语句做了两件事：

- 使用 dataType[arraySize] 创建了一个数组。
- 把新创建的数组的引用赋值给变量 arrayRefVar。

```java
// 也可以通过这种方式来创建数组
dataType[] arrayRefVar = {value0, value1, ..., valuek};
```

 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。 

------

### *java集合*

***数组和集合的比较***

1. 数组能存放基本数据类型和对象，而集合类存放的都是对象，集合类不能存放基本数据类型。数组和集合存放的对象皆为对象的引用地址。
2. 数组容易固定无法动态改变，集合类容量动态改变。
3. 数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数
4. 集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式
5. 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率

***集合的定义***

 Java集合类存放在java.util包中，是一个用来存放对象的容器。

Collection和Map，是集合框架的根接口。

 ***Iterator所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：***
1.**hasNext()**是否还有下一个元素。
2.**next()**返回下一个元素。
3.**remove()**删除当前元素。 

***Collection的子接口***

Set:接口 ---实现类： HashSet、LinkedHashSet
Set的子接口SortedSet接口---实现类：TreeSet
List:接口---实现类： LinkedList,Vector,ArrayList

***Map***

集合框架的第二类接口树。
它提供了一组键值的映射。其中存储的每个对象都有一个相应的关键字(key)，关键字决定了对象在Map中的存储位置。
关键字应该是唯一的，每个key 只能映射一个value。

**实现类：**
HashMap、TreeMap、LinkedHashMap、Hashtable等

- HashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；
- Hashtable：线程安全的，不允许null的键或值；
- Properties:  key和value都是String类型，用来读配置文件；
- TreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key; key要实现Comparable接口或TreeMap有自己的构造器；
- LinkedHashMap： 此实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。

***总结***

HashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table
 LinkedHashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table 与双链表
 TreeSet：实现 NavigableSet 接口，不允许重复的元素，底层数据结构红黑树
 ArrayList：实现 List 接口，允许重复元素，底层数据结构可变数组
 LinkedList：实现 List 接口，允许重复元素，底层数据结构双链表
 Vector：实现 List 接口，允许重复元素，底层数据结构可变数组
 HashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table
 LinkedHashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table 与双链表
 HashTable：实现 Map 接口，不允许重复的 key，底层数据结构 hash table
 TreeMap：实现 SortedMap 接口，不允许重复的 key，底层数据结构红黑树



------



### *java的方法*



**java方法的定义**

 Java方法是语句的集合，它们在一起执行一个功能 。

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

- **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。
- **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。
- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。
- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。
- **方法体：**方法体包含具体的语句，定义该方法的功能。

***void 关键字***

void 关键字修饰修饰方法表示该方法没有返回值，方法里可以不用return语句。

------

### *java继承*

***关键字：extends***

***java继承类型***

单继承

多重继承

不同类继承同一个类

java不支持多继承，可以通过接口实现多继承

***继承的特性***

- 子类拥有父类非 private 的属性、方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

------

### *java重写（override）和重载（overload）*

***重写***
 重写是<u>子类对父类</u>的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<u>即外壳不变，核心重写！</u> 

***重载***

 方法重载是指<u>在一个类中</u>，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。 

 方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。 

|  区别点  | 重载方法 |                   重写方法                   |
| :------: | :------: | :------------------------------------------: |
| 参数列表 | 必须不同 |                 一定不能修改                 |
| 返回类型 | 可以修改 |                 一定不能修改                 |
|   异常   | 可以修改 | 可以减少或删除，一定不能抛出新的或更广的异常 |
| 访问控制 | 可以修改 |            一定不能做更严格的限制            |

------

### *java多态*

<u>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作</u>

***多态存在的三个必要条件***

- 继承
- 重写
- 父类引用指向子类对象

***多态的实现方式***

- 重写
- 接口
- 抽象类和抽象方法

***多态的具体实现***

**接口的引用指向类的实列**

```java
List<?> list= new ArrayList<?>
```

为什么要用接口引用指向实现类的对象呢？

多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

List list;是在栈区开辟一个空间放list引用，并没有创建对象所以不知道ArrayList还是LinkedList当你list= new ArrayList(); 就创建了ArrayList对象。并且把开始创建的list引用指向这个对象ArrayList是List的实现类。

<u><font color=red>相当于ArrayList实现了List这个接口。</font></u>

------

### *java抽象类*

<u>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就叫抽象类。</u>

***抽象类的定义***

通过abstract class来定义一个抽象类；

抽象类不能被实列化；

抽象类和一般的类没有什么区别，都有成员变量，方法；

***抽象方法***

抽象方法使用abstract 定义。

抽象方法没有方法体，也就是没有方法内容。  public abstract double computePay(); 

继承抽象方法的子类必须重写该抽象方法，否则该子类也必须声明为抽象类。

抽象方法只能存在与抽象类中

***抽象类总结***

- 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
-  抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
-  构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
-  抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

## 

### *java接口*

 在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明  。一个类通过继承接口的方式，从而来继承接口的抽象方法。  接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

***接口与类相似点***

- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

***接口与类的区别***

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

***接口特性***

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

***抽象类和接口的区别***

-  抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
-  抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
-  接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

***接口的声明***

```java
[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
```

***接口有以下特性***

- 接口是隐式抽象的，当声明一个接口的时候，不必使用**abstract**关键字。
- 接口中每一个方法也是隐式抽象的，声明时同样不需要**abstract**关键字。
- 接口中的方法都是公有的

***接口的实现***

当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。

类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。

```java
...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
```

***重写接口中声明的方法时，需要注意以下规则*** 

- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。

***在实现接口的时候，也要注意一些规则***

- 一个类可以同时实现多个接口。
- 一个类只能继承一个类，但是能实现多个接口。
- 一个接口能继承另一个接口，这和类之间的继承比较相似。

------

### *java 包*

 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 

***包的作用***

- 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
- 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
- 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

***包语句的语法格式为***

```java
 package pkg1[．pkg2[．pkg3…]]; 
```

***创建包***

创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。

包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。

如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。

***import关键字***为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 "import" 语句可完成此功能。

在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：

------

### *java泛型*

***泛型的定义***
类的类型的参数化，或者类的类型也可以作为参数方法传递给类或者类的方法。

 在java中是指***把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型***。  

泛型的类型只能是引用型数据类型。

***泛型的声明***

java中使用<>声明一个泛型

***泛型的介绍***

- Java泛型类
- Java泛型方法
- Java泛型接口
- Java泛型擦除及其相关内容
- Java泛型通配符

***java泛型类***

 假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据 。

```java
// 通过给类设置参数，通过泛型类传入多个参数，这样可以一次性处理多种类型的数据
public class Pack <T>{
	T item;
	public  T name(T t) {
		return t;
	}
	public void getItem(T t) {
		 this.item = t;
	}
}

// 泛型类的使用，String 为传入的泛型类型。
Pack aPack = new Pack<String>();

```

***泛型接口***

```java
// 定义一个泛型接口
public interface A <T>{
    public T next(T num);
}
```

子类定义子类定义泛型的类型

```java
interface Info<T>{
    public T getValue();
}

// 子类直接实现接口，不指明类型
class InfoImpl<T> implements Info<T> {
    private T var;
    public InfoImpl(T var) {
        this.setVar(var);
    }
    public void setVar(T var) {
        this.var = var;
    }
    public T getVar() {
        return this.var;
    }
}
public class GenericsDemo24 {
    public static void main(String args[]) {
        Info<String> i = null;
        i = new InfoImpl<String>("123");
        System.out.println("hello: " + i.getVar());
    }
}

```

子类直接使用具体的类型

```java
interface Info<T>{        // 在接口上定义泛型
    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型
}
class InfoImpl implements Info<String>{   // 定义泛型接口的子类
    private String var ;                // 定义属性
    public InfoImpl(String var){        // 通过构造方法设置属性内容
        this.setVar(var) ;
    }
    public void setVar(String var){
        this.var = var ;
    }
    public String getVar(){
        return this.var ;
    }
};
public class GenericsDemo25{
    public static void main(String arsg[]){
        Info i = null;      // 声明接口对象
        i = new InfoImpl("Hello") ;   // 通过子类实例化对象
        System.out.println("内容：" + i.getVar()) ;
    }
};
```

***java泛型方法***

 泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。 

格式

```java
访问权限 <泛型标识>　泛型标识　方法名称(泛型标识　参数名称)
```



```java
// 无返回值的方法 
public <T> void show(T t) {
        System.out.println(t);
    }
// 有返回值的方法
class Demo{
    public <T> T fun(T t){            // 可以接收任意类型的数据
        return t ;                  // 直接把参数返回
    }
};
```

静态方法与泛型

 如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 

```java
public class StaticGenerator<T> {
    ....
    ....
    /**
     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
     * 如：public static void show(T t){..},此时编译器会提示错误信息：
          "StaticGenerator cannot be refrenced from static context"
     */
    public static <T> void show(T t){

    }
}
```

***java泛型的上下边界***

 在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 

------



### *java序列化*

***序列化和反序列化的概念***
 序列化：把对象转换为字节序列的过程称为对象的序列化。
反序列化：把字节序列恢复为对象的过程称为对象的反序列化。 

简单的说： 为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。

***什么时候需要序列化***
 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
当你想用套接字在网络上传送对象的时候；
当你想通过RMI传输对象的时候； 